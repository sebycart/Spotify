# Missing values

Fortunately, our dataset does not have too many NA's where it matters. As we obtained our data through Spotify's API, most of the variables we are interested in contain information on an artist or a song. This information is the most current data available - including the popularity of an artist or the audio features of a song. Most of these variables are generated by Spotify automatically, and therefore we rarely see unavailable data.

The following NA analysis is conducted on our main dataset that brings together the most popular rap and country songs across 8 different markets. Each row is a different track, and for each track we have information on its popularity, audio features, release date, song length, etc. In the following plot, we can see two columns that are populated with NA's (marked as yellow). The column that is almost entirely NA values is the `restrictions.reason` variable. The other column with NA's is the `preview_url` column, which basically contains a url with a preview of each track. Clearly, many tracks do not have such information, and this is likely due to music rights and/or label restrictions.

```{r}


# Load Packages  ----------------------------------------------------------


library(spotifyr)
library(tidyverse)
library(plyr); library(dplyr)
library(redav)
library(GGally)
library(jsonlite)
library(ggridges)
library(plotly)
library(shape)
library(sf)
library(mi)
library(jsonlite)


# Keys --------------------------------------------------------------------


Sys.setenv(SPOTIFY_CLIENT_ID = '2c522ebeb84f4aa189ec93288a41d97f')
Sys.setenv(SPOTIFY_CLIENT_SECRET = 'a82b80f800d54972844bf25de6f98ce2')
Sys.setenv(REDIRECT_URI = 'http://localhost:8888/callback')

access_token <- get_spotify_access_token()

authorization_token = get_spotify_authorization_code()



# Data Cleaning, Tidying, Wrangling  ---------------------------------------------------------------------


rap = get_genre_artists(genre = "rap")
country = get_genre_artists(genre = "country")



################# Pick 10 Most Popular Rappers Globally



for(i in 1:10){
  rapid = rap$id[i]
  artist_top_tracks = get_artist_top_tracks(rapid)
  if(i ==1){
    rap_topartist_toptracks = artist_top_tracks
  }
  else{
    rap_topartist_toptracks =  rbind(rap_topartist_toptracks,artist_top_tracks)
  }
  
}


################## Pick 10 Popular Country Artists Globally


for(i in 1:10){
  countryid = country$id[i]
  country_top_tracks = get_artist_top_tracks(countryid)
  if(i ==1){
    country_topartist_toptracks = country_top_tracks
  }
  else{
    country_topartist_toptracks =  rbind(country_topartist_toptracks,country_top_tracks)
  }
  
}

###Merge rap and country

rapartist_topsongs_ = rap_topartist_toptracks %>% 
  mutate(genre = "rap")

countryartist_topsongs_ = country_topartist_toptracks %>% 
  mutate(genre = "country")

rapcountry = rbind(rapartist_topsongs_,countryartist_topsongs_
)

rapcountry2 = rapcountry[!duplicated(rapcountry$id),]

###### Explore audio features 

audiofeatures_rap= get_track_audio_features(rapcountry2$id[rapcountry2$genre == "rap"])
audiofeatures_country= get_track_audio_features(rapcountry2$id[rapcountry2$genre == "country"])

rapcountry_audiofeatures = rbind(audiofeatures_rap,audiofeatures_country)

rapcountry_full = merge(rapcountry2,rapcountry_audiofeatures, by = "id" )
rapcountry_full$genre2 =ifelse( rapcountry_full$name == "Broadway Girls (feat. Morgan Wallen)",
                                "Collab",
                                rapcountry_full$genre)



rapcountry_full$albumpop = NA
for(i in 1:nrow(rapcountry_full)){
  if(rapcountry_full$album.album_type[i] == "album"){
    rapcountry_full$albumpop[i] = get_album(rapcountry_full$album.id[i])$popularity
  }
  else(rapcountry_full$albumpop[i] = NA)
}



################# Function that pulls top 20 rap songs from the top 20 artists in a market


rap_toptracks = function(countrycode){
  rap = get_genre_artists(genre = "rap",
                          market = countrycode)
  for(i in 1:20){
    rapid = rap$id[i]
    artist_top_tracks = get_artist_top_tracks(rapid,
                                              market = countrycode)
    if(i ==1){
      rap_topartist_toptracks = artist_top_tracks
    }
    else{
      rap_topartist_toptracks =  rbind(rap_topartist_toptracks,artist_top_tracks)
    }
    
  }
  
  data = rap_topartist_toptracks%>% 
    mutate(genre = "rap")%>%
    mutate(country = countrycode) 
  
  data = data[!duplicated(data$id),]
  
  return(data)}

###Function that pulls top 20 country songs from the top 20 artists in a market
country_toptracks = function(countrycode){
  country_topartists = get_genre_artists(genre = "country",
                                         market = countrycode)
  for(i in 1:nrow(country_topartists)){
    countryartist_id = country_topartists$id[i]
    artist_top_tracks = get_artist_top_tracks(countryartist_id,
                                              market = countrycode)
    if(i ==1){
      country_topartist_toptracks = artist_top_tracks
    }
    else{
      country_topartist_toptracks =  rbind.fill(country_topartist_toptracks,artist_top_tracks)
    }
    
  }
  data = country_topartist_toptracks %>% 
    mutate(genre = "country") %>%
    mutate(country = countrycode)
  
  data = data[!duplicated(data$id),]
  
  
  return(data)}


#####Top rap across markets

rapindia = rap_toptracks("IN") 
rapjapan = rap_toptracks("JP")
rapus = rap_toptracks("US")
rapgb = rap_toptracks("GB")
rapgh = rap_toptracks("GH")
rapfr = rap_toptracks("FR")
rapmx = rap_toptracks("MX")

######korean rap 
koreanrap_topartists = get_genre_artists(genre = "K-rap",
                                         market = "KR",
                                         limit = 35)

koreanrap_topartists = koreanrap_topartists[grepl("k-pop",koreanrap_topartists$genres )|grepl("k-rap",koreanrap_topartists$genres ), ] 


for(i in 1:nrow(koreanrap_topartists)){
  rapid_k = koreanrap_topartists$id[i]
  artist_top_tracks_k = get_artist_top_tracks(rapid_k,
                                              market = "KR")
  if(i ==1){
    rap_topartist_toptracks_k = artist_top_tracks_k
  }
  else{
    rap_topartist_toptracks_k =  rbind.fill(rap_topartist_toptracks_k,artist_top_tracks_k)
  }
  
}
rapkorea = rap_topartist_toptracks_k %>% 
  mutate(genre = "rap")%>%
  mutate(country = "KR") 

##remove duplicate readings (arise from popular rappers featuring on other's songs)
rapkorea = rapkorea[!duplicated(rapkorea$id),]


####bind rap datasets
rap_4 = rbind.fill(rapindia,
                   rapjapan,
                   rapus,
                   rapgb,
                   rapkorea,
                   rapgh,
                   rapfr,
                   rapmx)

###### Top country music across markets

countryindia = country_toptracks("IN")
countryjapan = country_toptracks("JP")
countrykorea = country_toptracks("KR")
countryus = country_toptracks("US")
countrygb = country_toptracks("GB")
countrygh = country_toptracks("GH")
countryfr = country_toptracks("FR")
countrymx = country_toptracks("MX")

country_4 = rbind.fill(countryindia,
                       countryjapan,
                       countryus,
                       countrygb,
                       countrykorea,
                       countrygh,
                       countryfr,
                       countrymx)

###Bring rap and country together
rapcountry_4 = rbind(rap_4,country_4)


rapcountry_4 =  rapcountry_4 %>% 
  group_by(country,genre) %>% 
  mutate(totaltracks = n()) %>% 
  mutate(explicitprop = sum(explicit)/n()) %>% 
  mutate(single = sum(album.album_type == "single"))%>% 
  mutate(singlepop = single/totaltracks)




rap_4_na = rap_4 %>% 
  mutate(across(everything(), as.character)) %>% 
  pivot_longer(names_to = "key", values_to = "value" , cols = -name) %>% 
  mutate(missing = ifelse(is.na(value), "yes", "no"))

rapcountry_4_na <- rapcountry_4 %>% 
  mutate(across(everything(), as.character)) %>% 
  pivot_longer(names_to = "key", values_to = "value" , cols = -name) %>% 
  mutate(missing = ifelse(is.na(value), "yes", "no"))

ggplot(rapcountry_4_na, aes(x = key, y = name, fill = missing)) +
  geom_tile(color = "white") + 
  scale_fill_viridis_d() + # discrete scale
  theme(axis.text.x = element_text(size = 4),
        axis.text.y = element_text(size = 2))

#missing_data.frame(rap_4)

rap_4_ = rap_4 %>% 
  group_by(country) %>% 
  mutate(`restrictions.reason.prop` = sum(is.na(restrictions.reason) == T)/n())



plot_missing2 <- function(x, percent = TRUE) {	
  na_count_all <- data.frame(is.na(x)) %>%	
    dplyr::group_by_all() %>%	
    dplyr::count(name = "count", sort = TRUE) %>%	
    dplyr::ungroup() %>%	
    tibble::rownames_to_column("pattern")	
  
  na_count_all <- na_count_all %>% 
    dplyr::mutate(pattern = factor(.data$pattern, levels = nrow(na_count_all):1))
  
  # count the number of columns with missing values; will be used later to determine if there's a "none missing" pattern	
  na_count_all <- na_count_all %>% 	
    dplyr::rowwise() %>%	
    dplyr::mutate(num_missing_cols = sum(dplyr::c_across(where(is.logical))))	
  
  # data frame for missing patterns bar chart	
  na_count_by_pattern <- na_count_all[,c("pattern", "count", "num_missing_cols")]
  na_count_by_pattern$none_missing <- ifelse(na_count_by_pattern$num_missing_cols == 0, TRUE, FALSE)

  # data frame for missing by column bar chart	
  na_count_by_column <- data.frame(is.na(x)) %>%	
    colSums() %>% 	
    sort(decreasing = TRUE) %>% 	
    tibble::enframe(name = "var", value = "count")	
  
  # tidy and sort na_count_all by column counts	
  na_count_all_tidy <- na_count_all %>% 	
    tidyr::pivot_longer(where(is.logical), names_to = "variable") %>%	
    dplyr::mutate(variable = factor(.data$variable, levels = na_count_by_column$var))  %>% 	
    dplyr::mutate(none_missing = ifelse(.data$num_missing_cols == 0, TRUE, FALSE))	
  
  # main plot
  main_plot <- ggplot2::ggplot(na_count_all_tidy, ggplot2::aes(.data$variable, .data$pattern, fill = factor(.data$value), alpha = .data$none_missing)) +	
    ggplot2::geom_tile(color = "white") +	
    ggplot2::scale_fill_manual(values = c("grey70", "mediumpurple")) +	
    ggplot2::scale_alpha_manual(values = c(.7, 1)) +	
    ggplot2::ylab("missing pattern") +	
    ggplot2::guides(fill = "none", alpha = "none") +	
    ggplot2::theme(axis.text.x = element_text(size = 4))	+
    ggplot2::scale_x_discrete(guide = guide_axis(n.dodge = 2))

  
  # check for "none missing" pattern
  none_missing_pattern <- na_count_by_pattern %>%
    dplyr::filter(.data$none_missing) %>% dplyr::pull(.data$pattern)
  
  if (length(none_missing_pattern) > 0) {	
    main_plot <- main_plot +	
      ggplot2::annotate("text", x = (ncol(na_count_all)-2)/2,	
               y = nrow(na_count_all) + 1 - as.numeric(as.character(none_missing_pattern)),	
               label = "complete cases")	
  }	
  
  # margin plots
  
  denom <- ifelse(percent, nrow(x)/100, 1)
  
  missing_by_column_plot <- ggplot2::ggplot(na_count_by_column, ggplot2::aes(forcats::fct_inorder(.data$var), .data$count/denom)) +	
    ggplot2::geom_col(fill = "cornflowerblue", alpha = .7) +
    ggplot2::scale_y_continuous(expand = c(0, 0), n.breaks = 3) +	
    ggplot2::xlab("") +
    ggplot2::ylab(ifelse(percent, "% rows \n missing:", "num rows \n missing:")) +	
    ggplot2::theme_linedraw(12) + 	
    ggplot2::theme(panel.grid.major.x = ggplot2::element_blank(),	
          panel.grid.minor.x = ggplot2::element_blank(),
          axis.text.x = ggplot2::element_text(size = 4))	+
    ggplot2::scale_x_discrete(guide = guide_axis(n.dodge = 2))	
    
  
  missing_by_pattern_plot <- 
    ggplot2::ggplot(na_count_by_pattern, ggplot2::aes(.data$pattern, .data$count/denom, alpha = .data$none_missing)) +
    ggplot2::geom_col(fill = "cornflowerblue") +
    ggplot2::coord_flip() +
    ggplot2::scale_y_continuous(expand = c(0, 0), n.breaks = 3) +
    ggplot2::scale_alpha_manual(values = c(.7, 1)) +
    ggplot2::xlab("") +
    ggplot2::ylab(ifelse(percent, "% rows", "row count")) +
    ggplot2::guides(alpha = "none") +
    ggplot2::theme_linedraw(12) +
    ggplot2::theme(panel.grid.major.y = ggplot2::element_blank(), 
          panel.grid.minor.y = ggplot2::element_blank())
  
  if (percent) {	
    missing_by_column_plot <- missing_by_column_plot +
      ggplot2::scale_y_continuous(expand = c(0, 0), n.breaks = 5,
                         limits = c(0, 100))	
    missing_by_pattern_plot <- missing_by_pattern_plot +
      ggplot2::scale_y_continuous(expand = c(0, 0), n.breaks = 5,
                         limits = c(0, 100))	
  }	
  
  missing_by_column_plot + patchwork::plot_spacer() + 	
    main_plot + missing_by_pattern_plot + 	
    patchwork::plot_layout(widths = c(4, 1), heights = c(1, 4))
}



```

Clearly there is an issue with the `restrictions.reason` column. This variable indicates whether a track is subject to restrictions in a given market. The plot below breaks down the number of NA's per market (8 total), and it clearly shows Korea has the least amount of NA's whereas the others only have NA's. Korea has restrictions on certain explicit music (we will discuss this more later on), so we can conclude that if a track has an NA value, then the market doesn't have a restriction, whereas if there is an NA value we can predict the track was released in the Korean market. 

```{r}
ggplot(data = rap_4_)+
  geom_point(aes(x = country, y = restrictions.reason.prop))+
  scale_y_continuous(breaks = seq(0.75,1,.05))+
  theme_minimal()
```

The following plot shows that there are no complete rows, but that the NA's are only present in two variables. On the right we see almost 60% of rows are missing data in the `restrictions.reason` column only, almost 50% of rows are missing data in both columns, and a very small amount are missing data in the `preview_url` column only. 

```{r}
plot_missing2(rapcountry_4)
```

